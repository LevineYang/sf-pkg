/** 
\page extendedkalmanfilter Extended Kalman Filter

\section Introduction 

A Kalman filter uses the physical model of a system (the plant) to
estimate the new value of a statistical variable. The extended Kalman
filter (EKF) can estimate states of nonlinear systems (= systems which
cannot be described by a matrix multiplication). This is done by
modeling the system as locally linear. \cite Rus10

Description of a nonlinear system (compared to the simple Kalman
filter functions instead of matrices are used):

\f[ x_k = f(x_{k-1}, u_{k-1}) + w_{k-1} \f]
\f[ z_k = h(x_{k}) + v_{k} \f]

- \f$x_k\f$ actual state on current step k
- \f$f\f$ state transition model
- \f$u\f$ control input
- \f$w\f$ process noise
- \f$z_k\f$ measurements taken on step k
- \f$h\f$ observation or measurement model
- \f$v\f$ measurement noise

The EKF approximates the models (\f$f\f$ and \f$h\f$) with the first
part of its Tailor serie (i.e. linearized locally at the previous
estimate).

\f[ x_k \approx \tilde x_{k} + A (x_{k-1} - \hat x_{k-1}) + w_{k-1} \f]
\f[ z_k \approx \tilde z_{k} + H (z_{k-1} - \hat z_{k-1}) + v_{k} \f]

- \f$x_k\f$ actual state
- \f$\tilde x_k\f$ first approximate of the (new) state, evaluated by
  ignoring the process noise: \f$\tilde x_k = f(x_{k-1},
  u_{k-1})\f$. This value is the a priori state vector, i.e. the
  expected state without taking the measurements into account.
- \f$\hat x_{k-1}\f$ estimated state of previous step (a posteriori of
  step \f$k-1\f$)
- \f$\tilde z_k\f$ expected measurement vector, evaluated by ignoring
  the measurement noise: \f$\tilde z_k = h(\tilde x_{k})\f$
- \f$A\f$ represents the first derivative of \f$f\f$, which is the
  Jacobian matrix of the partial derivatives of \f$f\f$ with respect to \f$x\f$.

  \f[ A_{[i,j]} = \frac{\delta f_{[i]}}{\delta x_{[j]}}(\tilde x_{k-1}, u_{k-1}, 0) \f]

- \f$H\f$ represents the first derivative of \f$h\f$, which is the
  Jacobian matrix of the partial derivatives of \f$h\f$ with respect
  to \f$x\f$.

  \f[ H_{[i,j]} = \frac{\delta h_{[i]}}{\delta x_{[j]}}(\tilde x_{k}, 0) \f]

One would notice that we aren't aware of the actual state \f$x_k\f$,
it's the state we want to estimate. The underlying theory of the EKF
substitutes \f$(x_{k-1} - \hat x_{k-1})\f$ away to get the (known)
formula for the a posteriori state, i.e. the estimate of the EKF.

For more details see \cite Wel06 and \cite Gre08. The notation is
taken from \cite Wel06.

\section Estimation

The estimation of EKF is similar to that of KF in its structure. First
the a priori state \f$\hat x_k(-)\f$ is estimated by the original
process model. For the a posteriori state \f$\hat x_k(+)\f$ the
approximation of the process model as a first order Tailor series is
used.

Predict (time update):
   \f[ \hat x_k(-) = f(x_{k-1}, u_{k-1}) \f]
   \f[ P_k(-) = A_k P_{k-1} A_k^T + Q_{k-1} \f]
Correct (measurement update):
   \f[ K_k = P_k(-) H_k^T (H_k P_k(-) H_k^T + R_k)^{-1} \f]
   \f[ \hat x_k(+) = \hat x_k(-) + K_k (z_k - h(\hat x_k(-))) \f]
   \f[ P_k(+) = P_k(-) - K_k H_k P_k(-) \f]

For details about the derivation of this formulas, see \cite Wel06 and
\cite Gre08.

\section Parameters

required:
- \b METHOD : "ExtendedKalmanFilter"
- \b STATE_TRANSITION_MODEL : The state transition model f, relates
  the previous state to the current state. f(x,u): a function f of x
  and u which represents the system ignoring the noise. Because the
  state consists of several variables the model is specified by a set
  of functions. One formula for each state variable is required. The
  state variables in the formulas correspond to the posteriori state
  of the last estimation. The variables are numbered from 0 to n-1,
  e.g. for n is 2, x[0] and x[1] are valid a posteriori state
  variables (the state is internally an array/vector). The formulas
  are evaluated and assigned to the a priori estimated state in the
  order they are given, i.e. the first item in the sequence will be
  applied to the a priori x[0], the second item to the a priori x[1],
  and so on.
- \b STATE_TRANSITION_MODEL_JACOBIAN : The Jacobian of the state
  transition model, i.e. partial derivatives of f with respect to
  x. The Jacobian of the state transition model is a matrix. An
  element A[i][j] = df[i]/dx[j], i.e. \em every formula of the state
  transition model is derived to \em every state variable. Therefore
  the size of this matrix must be n x n. E.g. deriving the first
  function of the state transition model to x gives the first row of
  A.
- \b PROCESS_NOISE_COVARIANCE : The process noise covariance Q. n x n
  Matrix.
- \b OBSERVATION_MODEL : The observation model h, relates the
  measurement to the state. h(x): a function h of x which represents
  the observation ignoring measurement noise.
- \b OBSERVATION_MODEL_JACOBIAN : The Jacobian of the observation
  model, i.e. partial derivatives of h with respect to x.
- \b MEASUREMENT_NOISE_COVARIANCE : The measurement noise covariance
  R. m x m Matrix.

optional:
- \b CONTROL_INPUT : The control input u. l-dim Vector.
- \b INITIAL_STATE : The initial state x0. n-dim Vector.
- \b INITIAL_ERROR_COVARIANCE : The initial error covariance P0. n x n
  Matrix.

\note
- The number of state variables n is extracted out of the sequence of
  formulas representing the state transition formula. This value is
  essential for the EKF. Hence write a formula for each state
  variable. Otherwise runtime errors can occur (invalid size of
  vectors/matrices).
- The models and its Jacobians have to be defined as functions. These
  functions are evaluated by the linear algebra library <a
  href="http://eigen.tuxfamily.org">Eigen</a> and the syntax is used
  right away. So check the <a
  href="http://eigen.tuxfamily.org/dox/group__QuickRefPage.html">quick-reference</a>
  of Eigen 3 for usage and examples, e.g. \f$x^2\f$ ... \c pow(x,2) or
  \c x.pow(2).
- Be careful to write appropriate sizes of the matrices and
  vectors. If the sizes don't fit an exception is thrown, which causes
  the ROS node to terminate.

Vectors must be specified as a list of floats separated by
commas. Matrices must be specified as lists of vectors enclosed by
curly brackets and separated by commas. Examples:
- 3-dimensional vector: 1, 2, 3
- 1-dimensional vector: 1
- 2x2-dimensional matrix: {1,0} , {0,1}
- 1x1-dimensional matrix: {1}
- 2x1-dimensional matrix: {1} , {1}

A set of functions is represented by a vector (where "set" is not the
correct description; "sequence" is better, because the order is
relevant!). A vector is represented by a sequence of elements, here:
the functions. A sequence is always enclosed by parantheses. Example
vector or sequence of functions: \code
#define STATE_TRANSITION_MODEL \
  ( x[0] + 0.1*x[1] )          \
  ( x[1] + 0.1*x[2] )          \
  ( x[2] )
\endcode

A matrix is represented by a sequence of sequences. Every row of a
matrix is a sequence of elements. And the matrix is a sequence of this
rows. Hence every element in a row is enclosed by parantheses, and the
row is enclosed by parantheses too. Example matrix or
sequence-of-sequences of functions: \code
#define STATE_TRANSITION_MODEL_JACOBIAN \
  ( (1) (0.1)  (0)  )                   \
  ( (0)  (1)  (0.1) )                   \
  ( (0)  (0)   (1)  )
\endcode

*/
